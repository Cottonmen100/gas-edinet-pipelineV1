test
/** ========= 設定 ========= **/
const SHEET_CONFIG = 'Config';
const SHEET_MAP    = 'Map';
const SHEET_OUT    = 'Output';

/** ========= 初期メニュー ========= **/
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('EDINET')
    .addItem('初期セットアップ', 'initLayout')
    .addSeparator()
    .addItem('KPI取得（モック）', 'runPipelineMock')
    .addSeparator()
    .addItem('レポート生成（フル）', 'Phase2_Step6_BuildFullReport')
    .addItem('会社指定レポート（Drive保存付き）', 'Phase3_RunByConfig')  // ← ここ
    .addToUi(); // ← 最後に1回だけ
}


/** ========= 初期レイアウト作成 ========= **/
function initLayout() {
  const ss = SpreadsheetApp.getActive();
  // Config
  let sh = ss.getSheetByName(SHEET_CONFIG);
  if (!sh) sh = ss.insertSheet(SHEET_CONFIG);
  if (sh.getLastRow() === 0) {
    sh.getRange(1,1,1,4).setValues([['会社名','EDINETコード','年度(YYYY)','備考']]);
  }

  // Map
  let map = ss.getSheetByName(SHEET_MAP);
  if (!map) map = ss.insertSheet(SHEET_MAP);
  if (map.getLastRow() === 0) {
    map.getRange(1,1,1,2).setValues([['KPI名','候補語（カンマ区切り）']]);
    // サンプル行
    map.getRange(2,1,3,2).setValues([
      ['売上高','SalesRevenue,Revenue,NetSales'],
      ['営業利益','OperatingIncome,OperatingProfit'],
      ['親会社株主純利益','ProfitAttributableToOwners,NetIncome']
    ]);
  }

  // Output
  let out = ss.getSheetByName(SHEET_OUT);
  if (!out) out = ss.insertSheet(SHEET_OUT);
  if (out.getLastRow() === 0) {
    out.getRange(1,1,1,2).setValues([['会社名','年度(YYYY)']]);
  }

  SpreadsheetApp.getUi().alert('初期セットアップ完了：Config / Map / Output を作成しました。');
}

/** ========= パイプライン（モック） ========= **/
function runPipelineMock() {
  const lock = LockService.getDocumentLock();
  lock.tryLock(30000);
  try {
    const ss = SpreadsheetApp.getActive();
    const cfg = ss.getSheetByName(SHEET_CONFIG);
    const map = ss.getSheetByName(SHEET_MAP);
    const out = ss.getSheetByName(SHEET_OUT);
    if (!cfg || !map || !out) throw new Error('Config/Map/Output が見つかりません。まず「初期セットアップ」。');

    // Config 読み込み
    const cfgRange = cfg.getDataRange().getValues();
    if (cfgRange.length < 2) throw new Error('Config に会社行を入力してください。');
    const cfgHeader = cfgRange[0];
    const rows = cfgRange.slice(1).filter(r => r.join('').trim() !== '');

    const colCompany = cfgHeader.indexOf('会社名');
    const colYear    = cfgHeader.indexOf('年度(YYYY)');
    const colCode    = cfgHeader.indexOf('EDINETコード'); // なくても進む
    if (colCompany < 0 || colYear < 0) throw new Error('Config に「会社名」「年度(YYYY)」ヘッダーが必要です。');

    // Map 読み込み
    const {kpis, normalizer} = readMapNormalized_(map);

    // Output ヘッダー整備（既存書式を保持）
    const header = ['会社名','年度(YYYY)', ...kpis.map(k => k.kpi)];
    out.getRange(1,1,1,header.length).setValues([header]);
    if (out.getLastRow() > 1) {
      const lastCol = Math.max(out.getLastColumn(), header.length);
      out.getRange(2,1,Math.max(out.getLastRow()-1,0), lastCol).clearContents();
    }

    // 各社処理
    const outRows = [];
    for (const r of rows) {
      const company = (r[colCompany] || '').toString().trim();
      const year    = (r[colYear] || '').toString().trim();
      const code    = (colCode >= 0 ? (r[colCode] || '').toString().trim() : '');
      if (!company || !year) continue;

      // ← フェーズBでここを edinet.gs の実関数へ置換予定
      const xbrl = Edinet.fetchXbrlByCodeYear(code || company, year);

      const row = [company, year];
      for (const {kpi, candidates, isRegex} of kpis) {
        // ① KPI名の直接一致（Edinet.fetch が日本語KPIを返すため）
        const dict = Object.fromEntries(Object.keys(xbrl).map(k => [normalizer(k), xbrl[k]]));
        const direct = dict[normalizer(kpi)];
        // ② 候補語での探索（英語タグや別名に対応）
        const val = (direct != null) ? direct : pickFirstAvailableNormalized_(xbrl, candidates, normalizer, isRegex);
        row.push(val ?? '');
      }
      outRows.push(row);
    }

    if (outRows.length) {
      out.getRange(2,1,outRows.length, header.length).setValues(outRows);
      out.autoResizeColumns(1, header.length);
    }
    SpreadsheetApp.getUi().alert('KPI取得（モック）完了。Output を確認してください。');
  } catch (e) {
    Logger.log('[runPipelineMock] %s', e && e.stack || e);
    SpreadsheetApp.getUi().alert('エラー: ' + e);
  } finally {
    lock.releaseLock();
  }
}

/** ========= Mapの正規化読み（追加） ========= **/
function readMapNormalized_(mapSheet) {
  const mapRange = mapSheet.getDataRange().getValues();
  if (mapRange.length < 2) throw new Error('Map にKPI行を入力してください。');
  const mapHeader = mapRange[0];
  const colKpi  = mapHeader.indexOf('KPI名');
  const colCand = mapHeader.indexOf('候補語（カンマ区切り）');
  if (colKpi < 0 || colCand < 0) throw new Error('Map に「KPI名」「候補語（カンマ区切り）」が必要です。');

  const normalizer = s => s.toString().trim()
    .replace(/[Ａ-Ｚａ-ｚ０-９]/g, c => String.fromCharCode(c.charCodeAt(0)-0xFEE0)) // 全角→半角
    .replace(/\s+/g,'')
    .toLowerCase();

  const kpis = mapRange.slice(1)
    .filter(r => r[colKpi] && r[colKpi].toString().trim() !== '')
    .map(r => {
      const raw = (r[colCand] || '').toString();
      const toks = raw.split(',').map(s => s.trim()).filter(Boolean);
      const parsed = toks.map(s => {
        if (s.startsWith('re:')) return {key: s.slice(3), isRegex: true};
        return {key: s, isRegex: false};
      });
      return { kpi: r[colKpi].toString().trim(), candidates: parsed, isRegex: null }; // isRegexは各要素に内包
    });

  // candidates を {kpi, candidates[], isRegex(使わない)} の形に展開
  const expanded = kpis.map(k => ({
    kpi: k.kpi,
    candidates: k.candidates,
    isRegex: false
  }));
  return {kpis: expanded, normalizer};
}



/** ========= モックの中身（後で本物に差し替え） ========= **/
function buildMockXbrl(company, year) {
  const bytes = Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, company + '|' + year);
  // 16バイトを4バイトずつ畳み込み
  let seed = 0;
  for (let i=0; i<bytes.length; i++) {
    seed = (seed * 131 + (bytes[i] & 0xff)) >>> 0;
  }
  const base = 100000 + (seed % 90000) * 100; // 100,000〜9,100,000
  return {
    SalesRevenue: base,
    Revenue: base,
    NetSales: base,
    OperatingIncome: Math.round(base * 0.08),
    OperatingProfit: Math.round(base * 0.08),
    ProfitAttributableToOwners: Math.round(base * 0.05),
    NetIncome: Math.round(base * 0.05),
    EquityRatio: 40 + (seed % 20) // 40〜59%
  };
}



function pickFirstAvailableNormalized_(obj, candidates, normalizeFn, _unused) {
  // 正規化されたキー辞書を構築
  const dict = {};
  Object.keys(obj).forEach(k => dict[normalizeFn(k)] = obj[k]);

  for (const c of candidates) {
    if (c.isRegex) {
      const rx = new RegExp(c.key, 'i');
      // オリジナルキーで評価（正規表現は人が書いた想定）
      const hit = Object.keys(obj).find(k => rx.test(k));
      if (hit) return obj[hit];
    } else {
      const nk = normalizeFn(c.key);
      if (nk in dict) return dict[nk];
    }
  }
  return null;
}

